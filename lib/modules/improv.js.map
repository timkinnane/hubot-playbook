{"version":3,"sources":["../../src/modules/improv.js"],"names":["instance","context","extensions","Improv","robot","defaults","save","fallback","process","env","IMRPOV_FALLBACK","replacement","IMRPOV_REPLACEMENT","use","improv","searchStack","item","isEqual","toString","middleware","findIndex","response","stack","brain","get","set","responseMiddleware","configure","options","Error","extend","dataFunc","isFunction","push","mergeData","user","dataSources","config","data","defaultsDeep","merged","reduce","merge","func","parse","strings","map","string","regex","RegExp","match","exec","template","Function","rendered","call","replace","e","log","warning","next","done","hasExpression","some","str","message","warn","unknowns","remember","path","value","forget","unset","reset"],"mappings":"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","file":"improv.js","sourcesContent":["'use strict'\n\nimport _ from 'lodash'\nimport Base from './Base'\n\n// init vars\nlet instance, context, extensions\n\n/**\n * Improv parses message templates at runtime with context from user attributes,\n * pre-populated data and/or custom extensions.\n *\n * e.g. \"hello ${ this.user.name }\" will render with the value at the user.name\n * path in current context.\n *\n * Message strings containing expressions are automatically rendered by Improv\n * middleware and can be merged with data from any source, including a\n * Transcript search for instance.\n *\n * Note:\n *\n * - The context object is applied as 'this' in the scope where the template is\n * rendered, e.g. `this.user.name` is the value at _user.name_ path.\n * - *Don't* use back-ticks when declaring strings, or it will render\n * immediately.\n * - Improv uses a singleton pattern to parse templates from a central\n * middleware. It should be initialised with a robot via `.use`.\n * - Calling `.reset()` will clear everything (for testing).\n *\n * @param {Robot} robot Hubot Robot instance\n * @return {Improv}     New or prior existing (singleton) instance\n */\nclass Improv extends Base {\n  constructor (robot) {\n    super('improv', robot)\n    if (!instance) {\n      instance = this\n      this.defaults({\n        save: true,\n        fallback: process.env.IMRPOV_FALLBACK || 'unknown',\n        replacement: process.env.IMRPOV_REPLACEMENT || null\n      })\n    }\n    return instance\n  }\n}\n\n/**\n * Setup middleware and improv context collection in the brain.\n *\n * This is the main interface to get either a new or existing instance.\n * If the robot is new but an instance exists (e.g. in tests) then Improv will\n * attach the new robot but keep existing config and extensions.\n *\n * @param  {Robot} robot The robot to use, usually existing from constructor\n * @return {Improv}      The instance - really only accessed by tests\n * @todo Test persistant context save/load from brain with a data store.\n */\nfunction use (robot) {\n  let improv = new Improv(robot)\n  let searchStack = (item) => _.isEqual(item.toString(), middleware.toString())\n  if (improv.robot == null ||\n  (_.findIndex(robot.middleware.response.stack, searchStack) < 0)) {\n    if (!robot.brain.get('improv')) robot.brain.set('improv', {})\n    robot.responseMiddleware(middleware)\n    improv.robot = robot\n  }\n  return improv\n}\n\n/**\n * Configure the Improv instance\n *\n * @param {Object} [options]             Key/val options for config\n * @param {boolean} [options.save]       Keep context collection in hubot brain\n * @param {string} [options.fallback]    Fallback content replace any unknowns within messages\n * @param {string} [options.replacement] Replace all messages containing unknowns, overrides fallback\n * @param {Object} [options.app]         Data object with app context attributes to merge into tempaltes\n * @param {array} [options.admins]       Array of usernames authorised to populate context data\n * @return {Object}                        The module exports for chaining\n */\nfunction configure (options = {}) {\n  if (!instance) throw new Error('Improv must be used with robot before configuring')\n  instance.configure(options)\n  return this\n}\n\n/**\n * Add extra functions to provide further context. They are called with the\n * current context whenever a template is rendered and should return extra\n * key/values to merge with context and/or override keys of existing data.\n *\n * @param  {Function} dataFunc Receives current context, to return more data\n * @return {Improv}            The instance for chaining\n *\n * @example <caption>extend context with user transcript history</caption>\n *\n * improv.use(robot)\n * improv.extend((context) => {\n *   context.user.favColor = 'always blue'\n *   return context\n * })\n * robot.send({ user: user }, 'I know your favorite color is ${ this.user.favColor }')\n * // ^ middleware will render template with the values and user in context\n*/\nfunction extend (dataFunc) {\n  if (!instance) throw new Error('Improv must be used with robot before extended')\n  if (_.isFunction(dataFunc)) {\n    if (extensions == null) extensions = []\n    extensions.push(dataFunc)\n  }\n  return this\n}\n\n/**\n * Provdies current context to messages merged with any data reutrn by added\n * extensions and a user object (if provideed).\n *\n * @param  {Object} [user] User (usually from middleware context)\n * @return {Object}        Context and user data, with any extensions merged\n *\n * @todo Allow tagging other user's data by merge with robot.brain.userForId\n*/\nfunction mergeData (user = {}) {\n  if (!instance) throw new Error('Improv must be used with robot before using data')\n  if (context == null) context = {}\n  let dataSources = [context, {user}]\n  if (instance.config.save) dataSources.push(instance.robot.brain.get('improv'))\n  let data = _.defaultsDeep({}, ...dataSources)\n  let merged = _.reduce(extensions, (merge, func) => {\n    return _.defaultsDeep(merge, func(merge))\n  }, data)\n  return merged\n}\n\n/**\n * Merge templated messages with context data (replace unknown as configured).\n * Called by middleware after context data gathered and possibly extended.\n *\n * Pre-renders each expression individually to catch and replace any unknowns.\n * Failed expressions will be replaced with fallback unless a full replacement\n * is configured, to replace the entire string.\n *\n * @param {array}  strings One or more strings being posted\n * @param {Object} context Template data, reference as 'this' for interpolation\n * @return {array}         Strings populated with context values\n*/\nfunction parse (strings, data) {\n  return _.map(strings, (string) => {\n    let regex = new RegExp(/(?:\\$\\{\\s?)(.*?)(?:\\s?\\})/)\n    let match\n    while ((match = regex.exec(string)) !== null) {\n      try {\n        let template = new Function(`return \\`${match[0]}\\``) // eslint-disable-line\n        // â¬† StandardJS error: The Function constructor is eval\n        let rendered = template.call(data)\n        string = string.replace(match[0], rendered)\n      } catch (e) {\n        instance.log.warning(`'${match[1]}' unknown in improv context for message: ${string}`)\n        if (instance.config.replacement !== null) return instance.config.replacement\n        else string = string.replace(match[0], instance.config.fallback)\n      }\n    }\n    return string\n  })\n}\n\n/**\n * Middleware checks for template tags and parses if required.\n *\n * @param  {Object}   context - Passed through middleware stack, with res\n * @param  {Function} next    - Called when all middleware is complete\n * @param  {Function} done    - Initial (final) completion callback\n*/\nfunction middleware (context, next, done) {\n  let hasExpression = _.some(context.strings, str => str.match(/\\${.*}/))\n  if (hasExpression) {\n    let data = mergeData(context.response.message.user)\n    context.strings = parse(context.strings, data)\n  }\n  return next()\n}\n\n/**\n * @todo ask configured admins to provide context for any unknowns\n */\nfunction warn (unknowns) {}\n\n/**\n * Add data to context on the fly\n *\n * @param {array/string} path The path of the property to set\n * @param {*} value           The value to set\n * @return {Object}             The module exports for chaining\n *\n * @todo Save to brain on update if configured to save\n */\nfunction remember (path, value) {\n  if (context == null) context = {}\n  _.set(context, path, value)\n  return this\n}\n\n/**\n * Remove data from context on the fly\n *\n * @param {array/string} path The path of the property to unset\n * @return {Object}             The module exports for chaining\n *\n * @todo Clear from brain on update if configured to save\n */\nfunction forget (path) {\n  if (context == null) context = {}\n  else _.unset(context, path)\n  return this\n}\n\n/**\n * Wipte slate for tests to reinitialise without existing instance or context\n */\nfunction reset () {\n  instance = null\n  extensions = null\n  context = null\n}\n\nexport default {\n  Improv: Improv,\n  use: use,\n  configure: configure,\n  extend: extend,\n  mergeData: mergeData,\n  parse: parse,\n  warn: warn,\n  remember: remember,\n  forget: forget,\n  reset: reset,\n  get instance () { return instance },\n  get context () {\n    if (context == null) context = {}\n    return context\n  },\n  get extensions () {\n    if (extensions == null) extensions = []\n    return extensions\n  },\n  get config () { return instance.config }\n}\n"]}